# $HOME/Dropbox/dev/ltm_helpers

#####################################################
# Creates several command aliases, generates custom bash & tmsh prompts,
# and defines several bash functions. 
#
# Copyright, F5 Networks, 2009-2018
# Written by: Jesse Driskill, ITC Systems Engineer
#####################################################


# use vi-mode cli
#set -o vi

# Define some environment vars
export EDITOR=vi


VERSION=$(awk '/Version/ { print $2 }' /VERSION)
export v4="4.*"    # BIG-IQ
export v10="10.*"
export v11="11.*"
export v12="12.*"
export v13="13.*"

# Aliases should be in here.
alias ll='ls -l --color=always'
alias lh='ls -lh --color=always'
alias la='ls -lA --color=always'
alias duh='du -h --max-depth=1'
alias vi=vim
alias last='last -20'
alias resource="source /shared/bin/env.ltm"

## F5-specific aliases
alias t=tmsh
alias conf=tmsh
alias quit=exit
alias slot1='ssh slot1'
alias slot2='ssh slot2'
alias slot3='ssh slot3'
alias slot4='ssh slot4'
alias slot5='ssh slot5'
alias slot6='ssh slot6'
alias slot7='ssh slot7'
alias slot8='ssh slot8'
alias ssc='tmsh save sys config'
alias bt-vips='bigtop -n -vname -delay 1 -nodes 0 -conn -delta'
alias bt-nums='bigtop -n -delay 1 -nodes 0 -conn -delta'
alias bt-vname='bigtop -n -vname -delay 1 -nodes 0 -conn'
alias bt-pkts='bigtop -n -delay 1 -nodes 0 -pkts -delta'
alias bt-nodes='bigtop -n -delay 1 -vips 0 -conn -delta'
alias listprofiles='tmsh list ltm profile | grep profile'
alias shownodes="tmsh list ltm node | awk /^ltm/'{print $3}'"
alias listvips="tmsh list ltm virtual | awk /^ltm/'{print $3}'"
alias showmem='tmsh show sys tmm-info raw | grep -E "Sys|Memory|Avail|Used|--"'
alias watchmem='watch "tmsh show sys tmm-info raw | grep -E \"Sys|Memory|Avail|Used|--\""'
alias getmem="tmsh sh sys tmm-info global"
alias showintstats="tmsh reset-stats net interface; watch -n 1 'tmsh show net interface'"
alias showsoftware="tmsh show sys software | awk '/BIGIP/ { print $4 }'"
alias getver='head -5 /VERSION'
alias tmctl='tmctl -w 100'
alias tmstat='tmstat summary'
alias huptmm='tmsh restart sys service tmm'
alias failover="tmsh run sys failover standby"
alias offline="tmsh run sys failover offline"
alias online="tmsh run sys failover online"
alias clearpersist="tmsh delete ltm persistence persist-records"
alias clearconns='tmsh delete sys conn all'

alias getPvaConns="tmctl epva_connstat -s slot_id,tmm,flows_by_hardware"
alias getTmmConns="tmctl tmm_stat -Ss slot_id,cpu,client_side_traffic.cur_conns,server_side_traffic.cur_conns"
alias watchTmmConns="watch tmctl tmm_stat -Ss slot_id,cpu,client_side_traffic.cur_conns,server_side_traffic.cur_conns"
alias watchTmmConns2="watch tmctl tmm_stat -Ss client_side_traffic.cur_conns,server_side_traffic.cur_conns,cpu,slot_id"



# display pagemem block allocation and % utilized
getPagemem() {

  if [[ $VERSION =~ $v12 || $VERSION =~ $v11 || $VERSION =~ $v4 ]]; then
    tmctl -qd blade tmm/pagemem | awk '{ print $2" "$3" ( " $2/$3*100 "% )" }'
  else
    #tmctl -w 500 -qd blade page_stats | awk '{ print "TMM "$1": "$2" "$3" ( " $2/$3*100 "% )" }'
    tmctl -w 500 -qd blade page_stats | awk '{ printf("TMM %02d: %8d %8d (%3d%% )\n", $1, $2, $3, $2/$3*100 ) }'
  fi
}
#alias getPagemem="tmctl -qd blade tmm/pagemem | awk '{ pct = ($2 / $3) * 100; print $2\" \"$3" ( \"pct\"% )\" }'"


# Update /var/run/config/syslog-ng.conf to stop displaying logs to usertty
no_console_logging() {
  sed -i -e 's/usertty(\"\*\")/file("\/var\/log\/console.log")/' /var/run/config/syslog-ng.conf
  tmsh restart sys service syslog-ng
}


## General LTM Functions
# push a config-sync to the device-group
sync() {
  if [ -n "$1" ]; then
    syncgroup=$1
  else
    syncgroup=$(tmsh list cm device-group one-line | awk /sync-failover/'{print $3}')
  fi
  echo "Syncing local config to $syncgroup"
  tmsh run cm config-sync to-group $syncgroup
}

# relicense the system
# either with the specified regkey (if provided) or with the previous key (from bigip.license).
relicense() {
  if [ -n "$1" ]; then
    key=$1
  else
    key=$(awk '/Reg/ { print $4 }' /config/bigip.license)
  fi
  echo "Running: SOAPLicenseClient --verbose --basekey $key"
  SOAPLicenseClient --verbose --basekey $key 
}

# tail all log files except those matched by globignore
taillogs() {
  shopt -s extglob
  GLOBIGNORE="/var/log/*gz:/var/log/disk_*log:/var/log/audit:/var/log/lastlog:/var/log/secure:/var/log/wtmp:/var/log/webui*:/var/log/wtmp*:/var/log/wccp*:/var/log/restjavad*:/var/log/tomcat:/var/log/*.1:/var/log/tmm.start:/var/log/ts:/var/log/wa:/var/log/wocplugin*:/var/log/vcmpvm.start:/var/log/rewrite*:/var/log/rpmpkgs:/var/log/sa*:/var/log/liveinstall*:/var/log/hitless*:/var/log/ecm:/var/log/omapd:/var/log/pkcs11d.debug"

  tail -n0 -f /var/log/* 2>/dev/null | strings
}

# Enabled Bash VI-mode if $VIMODE=1 (sent as SSH env variable)
chk_vi_mode() {
if [ -n "$VIMODE" ]; then
  if [ $VIMODE -eq 1 ]; then
    set -o vi
  fi
fi
}

# Force mcpd to load from config files on one or all blades
forceload() {
  if [ -n "$1" ]; then
    echo "Performing forceload on slot $1 only"
    ssh $1 touch /service/mcpd/forceload
    ssh $1 tmsh restart sys service all
  else
    echo "Performing forceload on all active slots"
    clsh touch /service/mcpd/forceload
    clsh tmsh restart sys service all
  fi
}

get_memory() {
  totalMem=$(tmsh sh sys tmm-info global raw | awk '/Available/ {print $2}')
  usedMem=$(tmsh sh sys tmm-info global raw | awk '/Used/ {print $2}')
  pctUsed=$(calc "($usedMem / $totalMem)*100")

  printf "Used %'d out of %'d available (${pctUsed}%)\n" $usedMem $totalMem $pctUsed
}

wipenodes() {
  NODES=$(tmsh list ltm node | awk /ltm\ node/'{print $3}')
  for n in $NODES; do
    tmsh delete ltm node $n 2>/dev/null && echo "Deleting node '$n'"
  done
}


clearstats() {
  if [[ -n "$1" ]]; then
    b $1 all stats reset
  else
    tmsh reset-stats net interface 
    tmsh reset-stats ltm virtual
    tmsh reset-stats ltm pool
    tmsh reset-stats ltm node
    tmsh reset-stats ltm rule
    tmsh reset-stats sys performance all-stats
    tmsh reset-stats sys traffic
    tmsh reset-stats sys tmm
  fi
}

showpersist() {
  nodes=$*
  if [[ -z "$nodes" ]]; then
    echo "USAGE: showpersist nodeaddr1 [nodeaddr2 ...]"
    return
  fi

  while (true); do
    tmsh show ltm persistence persist-records >/tmp/persist_records.txt
    for n in $nodes; do
      echo "$n: $(grep -c $n /tmp/persist_records.txt)"
    done
    rm /tmp/persist_records.txt
    sleep 5
  done
}

syncslots() {
  if [[ -n "$1" ]]; then
    SLOT=$1
  else
    echo "USAGE: syncslots slot<ID> (EX: syncslots slot3)"
    return
  fi

  test -f /shared/env.ltm || {
    echo "/root/.env.ltm does not exist. Exiting..."
    return
  }

  scp /shared/env.ltm ${SLOT}:/shared/env.ltm
  scp /shared/vimrc.ltm ${SLOT}:/shared/vimrc.ltm
  ssh $SLOT "ln -sf /shared/env.ltm .env.ltm"
  ssh $SLOT "ln -sf /shared/vimrc.ltm .vimrc"

  ssh $SLOT "sed -i -e \"s/^cd \/config/#cd \/config/\" .bash_profile"
  ssh $SLOT "echo \"alias src='. /shared/env.ltm'\">> .bash_profile"
  ssh $SLOT "echo \"source /shared/env.ltm\">> .bash_profile"
  ssh $SLOT "touch .hushlogin"
  ssh $SLOT "sed -i -e \"s/^clear/#clear/\" .bash_logout"
}

# Disable a cluster member (blade)
disable() {
  if [[ -z "$1" ]]; then
    echo "USAGE: disable <slot#>"
    return
  else
    echo tmsh modify sys cluster default members { $1 { disabled }}
    tmsh modify sys cluster default members { $1 { disabled }}
  fi
}

# Enable a cluster member (blade)
enable() {
  if [[ -z "$1" ]]; then
    echo "USAGE: enable <slot#>"
    return
  else
    echo tmsh modify sys cluster default members { $1 { enabled }}
    tmsh modify sys cluster default members { $1 { enabled }}
  fi
}

# aliases to remove... get rid of rm|cp|mv interactivity
cmds="mv cp rm ps"
for i in $cmds; do
  alias | grep -q $i && unalias $i 2> /dev/null
done

##
## PEM functions
##
alias pem_del_subs="tmsh delete pem sessiondb all"

pem_count_subs() {
  tmm=$(tmsh show sys tmm-info global | awk '/TMM Count/{print $3}')
  total=0

  for (( c=0; $c < $tmm; c++)); do
    num=$(tmsh show pem sessiondb view-mode count tmm $c | awk '{ print $4 }')
    printf "TMM %02d: %d\n"  $c $num

    ((total+=num))
  done
  printf "Total sessions: %d\n" $total
}

##
## APM functions
##
#alias watchApmSessions='watch -n5 "sessiondump -list | wc -l"'
#alias listApmSessions='sessiondump -list | wc -l'
alias apm_watch_sessions='watch -n5 "sessiondump --list | wc -l"'
alias apm_count_sessions="echo Sessions: $(sessiondump --list | wc -l)"
alias apm_del_sessions='sessiondump --delete all'

#apm_count_sessions() {
#  echo "Sessions: $(sessiondump --list | wc -l)"
#}


# customize some tmsh options and define some aliases
mk_tmsh_aliases() {
  VERSION=$(awk '/Version/ { print $2 }' /VERSION)
  if [[ $VERSION =~ $v13 || $VERSION =~ $v12 || $VERSION =~ $v11 || $VERSION =~ $v4 ]]; then
    #v11.x
    echo "Creating aliases for LTM v11+ and BIG-IQ v4+"
    tmsh modify cli preference history-date-time enabled 2>/dev/null
    #tmsh modify cli preference keymap vi 2>/dev/null
    tmsh modify cli preference editor vi tcl-syntax-highlighting enabled
    tmsh modify cli preference prompt { host status current-folder multi-line } 2>/dev/null
    tmsh modify sys db ui.system.preferences.startscreen value virtual_servers
    tmsh modify sys db ui.system.preferences.recordsperscreen value 100
    tmsh modify sys db ui.system.preferences.advancedselection value advanced
    tmsh modify sys global-settings file-whitelist-path-prefix "{/var/local/scf} {/tmp/} {/shared/} {/config/} {/root}" 2>/dev/null
    tmsh create cli alias shared exit         command "quit" 2>/dev/null
    tmsh create cli alias shared ssc          command "save sys config" 2>/dev/null
    tmsh create cli alias shared ping         command "run util ping" 2>/dev/null
    tmsh create cli alias shared ping6        command "run util ping6" 2>/dev/null
    tmsh create cli alias shared tcpdump      command "run util tcpdump" 2>/dev/null
    tmsh create cli alias shared clear        command "run util bash -c clear" 2>/dev/null
    tmsh create cli alias shared huptmm       command "run util bash -c 'clsh tmsh restart sys service tmm'" 2>/dev/null
    tmsh create cli alias shared failover     command "run sys failover standby" 2>/dev/null
    tmsh create cli alias shared offline      command "run sys failover offline" 2>/dev/null
    tmsh create cli alias shared online       command "run sys failover online" 2>/dev/null
    tmsh create cli alias shared sync         command "run cm config-sync to-group fo_group" 2>/dev/null
    tmsh create cli alias shared list_srv_ssl command "list ltm profile server-ssl" 2>/dev/null
    tmsh create cli alias shared list_clt_ssl command "list ltm profile client-ssl" 2>/dev/null
    tmsh create cli alias shared clearconns   command "delete sys conn all" 2>/dev/null
    #tmsh create cli alias shared imish        command "run util imish" 2>/dev/null
  else
    #v10.2.x
    echo "Creating aliases for LTM v10.x"
    tmsh modify cli preference editor vi
    tmsh modify cli preference prompt { host status multi-line }
    tmsh create cli alias ping    command "run util ping" 2>/dev/null
    tmsh create cli alias ping6   command "run util ping6" 2>/dev/null
    tmsh create cli alias tcpdump command "run util tcpdump" 2>/dev/null
    tmsh create cli alias clear   command "run util bash -c clear" 2>/dev/null
    tmsh create cli alias exit    command "quit" 2>/dev/null
    tmsh create cli alias huptmm  command "run util bash -c clsh tmsh restart sys service tmm" 2>/dev/null
    tmsh create cli alias ssc     command "save sys config" 2>/dev/null
    tmsh create cli alias showtcp command "show sys connection protocol tcp"
    tmsh modify cli global-settings service number
  fi
}

# Configure basic ltm settings
# $1 - domain that should be used (default: pl.itc.f5net.com)
# $2 - management gateway (default: .254 on the same network as the management-ip)
mk_default() {
  if [ -n "$1" ]; then domain=$1
  else domain="pl.itc.f5net.com"
  fi

  if [ -n "$2" ]; then mgmt_gtwy=$2
  fi

  echo -n "Please enter the hostname (domain will be: ${domain}): "
  read name
  echo "Using ${name}.${domain}"
  tmsh modify sys global-settings hostname ${name}.${domain}
  tmsh modify sys global-settings gui-setup disabled
  tmsh modify sys dns name-servers add { 172.22.48.10 172.27.1.1 }
  tmsh modify sys dns search add { pl.itc.f5net.com }
  tmsh modify sys ntp servers add { 172.22.48.10 }
  tmsh modify sys snmp allowed-addresses add { ALL }
  tmsh modify sys httpd auth-pam-idle-timeout 86400
  tmsh modify sys db bigpipe.displayservicenames value false
  tmsh modify sys db platform.powersupplymonitor value disable

  # disable miserable password policy in v13.1 and higher
  #tmsh modify auth password-policy policy-enforcement disabled
  #tmsh modify auth password admin    # may require interaction with passwd prompt
  #tmsh modify auth password root     # may require interaction with passwd prompt

  # modify sshd to accept the 'VIMODE' variable (for bash behavior)
  tmsh modify sys sshd include "AcceptEnv VIMODE"

  # assign management default route
  if [ -z $mgmt_gtwy ]; then
    mgmt_ip=$(tmsh list sys management-ip | awk '{print $3}' | sed 's/\/..//')
    if [[ -z $mgmt_ip ]]; then
      mgmt_ip=$(tmsh show sys cluster field-fmt | awk '/address/ { print $2 }' | sed 's/\/..//')
    fi
    mgmt_net=$(echo $mgmt_ip | awk 'BEGIN { FS="." } { print $1"."$2"."$3 }')
    mgmt_gtwy="${mgmt_net}.254"
  fi
  tmsh modify sys management-route default gateway $mgmt_gtwy
}


### define the custom prompt
PROMPT_DIRTRIM=4
TITLE='\[\e]0;\h\a'
BLINK="\[\e[5m\]"
CLR="\[\e[0m\]"
GREEN="\[\e[0;32m\]"
RED="\[\e[0;31m\]"
BLUE="\[\e[0;34m\]"
CYAN="\[\e[0;36m\]"
PURPLE="\[\e[0;35m\]"
BROWN="\[\e[0;33m\]"
LTBLUE="\[\e[1;34m\]"
LTGREEN="\[\e[1;32m\]"
LTRED="\[\e[1;31m\]"
LTCYAN="\[\e[1;36m\]"
YELLOW="\[\e[1;33m\]"
WHITE="\[\e[1;37m\]"


v4="4.*"    # BIG-IQ
v10="10.*"
v11="11.*"
v12="12.*"
v13="13.*"

export PLATFORM=$(awk 'BEGIN{FS="=" } /platform/ {print $2}' /PLATFORM)

# Viprion does a couple things differently than appliances.
# We need to know which we are working with.
case $PLATFORM in
  "A100")
    export VIPRION=1
    ;;
  "A107")
    export VIPRION=1
    ;;
  "A108")
    export VIPRION=1
    ;;
  "A109")
    export VIPRION=1
    ;;
  "A110")
    export VIPRION=1
    ;;
  "A111")
    export VIPRION=1
    ;;
  "A112")
    export VIPRION=1
    ;;
  "A113")
    export  VIPRION=1
    ;;
  "A114")
    export  VIPRION=1
    ;;
  "Z101")
    export  VIPRION=2
    ;;
  *)
    export VIPRION=0
    ;;
esac

# enable DEBUG mode
export DEBUG=0

#custom prompt
mk_prompt () {
  # Get failover state and sync status
  read pStatus  < /var/prompt/ps1
  if [ -f /var/prompt/cmiSyncStatus ]; then read SYNC < /var/prompt/cmiSyncStatus; else SYNC="Unknown"; fi

  goodFO="(Active|Standby|Standalone|Disconnected|In Sync)"
  badFO="(Offline|INOPERATIVE|REBOOT REQUIRED)"
  single="(Standalone)"
  syncStatus="(In Sync|Standalone|Changes Pending|Awaiting Initial Sync|Not All Devices Synced|Changes Pending)"

  # Determine whether this is a redundant or standalone system
  if [[ "$SYNC" =~ $single ]]; then STANDALONE=${BASH_REMATCH[0]}; fi

  if  [[ $VIPRION -eq 0 ]]; then  # Appliance
    if [[ "$pStatus" =~ $goodFO ]]; then FO=${BASH_REMATCH[1]}; fi

    if [[ -z "$STANDALONE" ]]; then # Redundant
      (($DEBUG)) && echo "Redundant Appliance"
      if [[ "$FO" =~ $goodFO ]]; then
        if [[ "$SYNC" =~ $syncStatus ]]; then
          PS1="${TITLE}${GREEN}${FO}, ${SYNC}${CLR}\n\h:\w >"
        else
          (($DEBUG)) && echo "Code 1"
          PS1="${TITLE}${LTCYAN}${pStatus}, ${SYNC}${CLR}\n\h:\w >"
        fi
      else # Unknown Failover state ($FO)
        (($DEBUG)) && echo "Code 2"
        PS1="${TITLE}${YELLOW}Slot ${FO}, ${SYNC} (Unknown failover state: ${FO})${CLR}\n\h:\w >"
      fi
    else # Standalone
      (($DEBUG)) && echo "Standalone Appliance"
      if [[ "$pStatus" =~ $goodFO ]]; then
        FO=${BASH_REMATCH[1]}
        (($DEBUG)) && echo "$FO, $pStatus"

        if [[ "$FO" =~ $goodFO ]]; then
          (($DEBUG)) && echo "Code 3"
          PS1="${TITLE}${GREEN}${FO}, ${SYNC}${CLR}\n\h:\w >"
        fi
      else # System is not in Active or Standby
        (($DEBUG)) && echo "Code 4"
        echo "haState: $haState, FO: $FO, STANDALONE: $STANDALONE"
        PS1="${TITLE}${RED}($pStatus), ${SYNC}${CLR}\n\h:\w >";
      fi
    fi

  elif [[ $VIPRION -eq 1 ]]; then # viprion platform
    if [ -f /SLOT ]; then read SLOT < /SLOT; else SLOT=0; fi

    viprionStatus="\/S([12345678])-([[:alpha:]]*)?-([PS]):([[:alpha:]]*|[[:alpha:]]* [[:alpha:]]*)?:?([[:alpha:]]*)?"
    if [[ "$pStatus" =~ $viprionStatus ]]; then
      SLOT=${BASH_REMATCH[1]}
      colorState=${BASH_REMATCH[2]}
      haState=${BASH_REMATCH[3]}
      mgmtState=${BASH_REMATCH[4]}
      FO=${BASH_REMATCH[5]}

      # If the licensed has expired or the system is unlicensed, set the prompt to that and return
      if [[ $mgmtState =~ "LICENSE EXPIRED" ]]; then
        PS1="${TITLE}${GREEN}Slot ${SLOT} ${RED}${BLINK}${mgmtState}${CLR}\n\h:\w >"
        return
      fi

      # if /var/prompt/ps1 doesn't contain the FO status, get it from $SYNC (/var/prompt/cmiSyncStatus)
      if [[ -z $FO ]]; then FO=$SYNC; fi

      (($DEBUG)) && echo "DEBUG: slot:$SLOT, color:$colorState, haState:$haState, mgmtState:$mgmtState, fo:'$FO'"

      # Base prompt of failover state
      if [[ "$FO" =~ $goodFO ]]; then
        if [[ "$SYNC" =~ $syncStatus ]]; then
          PS1="${TITLE}${GREEN}Slot ${SLOT}, (${FO}) ${mgmtState} ${CLR}\n\h:\w >"
        else
          PS1="${TITLE}${CYAN}Slot ${SLOT}, (${FO}) ${mgmtState} ${CLR}\n\h:\w >"
        fi
      elif [[ $FO =~ $badFO ]]; then
        PS1="${TITLE}${RED}Slot ${SLOT}, ${FO}${CLR}\n\h:\w >"
      fi
    else  # System is not in Active or Standby FO state
      PS1="${RED}Slot ${SLOT}, (Failover unknown), ${SYNC}${CLR}\n\h:\w >"
    fi

  elif  [[ $VIPRION -eq 2 ]]; then # vCMP guest on VIPRION
    if [[ "$pStatus" =~ $goodFO ]]; then FO=${BASH_REMATCH[1]}; fi

    if [[ -z "$STANDALONE" ]]; then # Redundant
      (($DEBUG)) && echo "Redundant Appliance"
      if [[ "$FO" =~ $goodFO ]]; then
        if [[ "$SYNC" =~ $syncStatus ]]; then
          PS1="${TITLE}${GREEN}${FO}, ${SYNC}${CLR}\n\h:\w >"
        else
          (($DEBUG)) && echo "Code 5"
          PS1="${TITLE}${LTCYAN}${pStatus}, ${SYNC}${CLR}\n\h:\w >"
        fi
      else # Unknown Failover state ($FO)
        (($DEBUG)) && echo "Code 6"
        PS1="${TITLE}${YELLOW}Slot ${FO}, ${SYNC} (Unknown failover state: ${FO})${CLR}\n\h:\w >"
      fi
    else # Standalone
      (($DEBUG)) && echo "Standalone Appliance"
      if [[ "$pStatus" =~ $goodFO ]]; then
        FO=${BASH_REMATCH[1]}
        (($DEBUG)) && echo "$FO, $pStatus"

        if [[ "$FO" =~ $goodFO ]]; then
          (($DEBUG)) && echo "Code 7"
          PS1="${TITLE}${GREEN}${FO}, ${SYNC}${CLR}\n\h:\w >"
        fi
      else # System is not in Active or Standby
        (($DEBUG)) && echo "Code 8"
        echo "haState: $haState, FO: $FO, STANDALONE: $STANDALONE"
        PS1="${TITLE}${RED}($pStatus), ${SYNC}${CLR}\n\h:\w >";
      fi
    fi

  else  # UNKNOWN platform type
    (($DEBUG)) && echo "Code 9"
    echo "(unknown platform) haState: $haState, FO: $FO, STANDALONE: $STANDALONE"
    PS1="${TITLE}${RED}($pStatus), ${SYNC}${CLR}\n\h:\w >";
  fi
}
export PROMPT_COMMAND=mk_prompt



# ex: set syntax=sh tabstop=2 expandtab: 
